from hyperion.lib.util.exception import CircularReferenceException


class Node(object):
    """This class models a component as node of a dependency tree."""

    pass

    def __init__(self, comp):
        """Initialize node for component `comp`.

        Parameters
        ----------
        comp : Component
            Component to create a node for.
        """

        self.component = comp
        self.depends_on = []
        self.comp_id = comp["id"]

    def add_edge(self, node):
        """Add a node as dependency.

        Parameters
        ----------
        node: Node
            Node to add as dependency
        """

        self.depends_on.append(node)

    def __repr__(self):
        return f"Node({self.comp_id})"

    def __str__(self):
        return f"Node({self.comp_id})"


def dep_resolve(node, resolved, unresolved):
    """Recursively generate a list of all dependencies for `node`.

    Parameters
    ----------
    node : Node
        Node to resolve dependencies for
    resolved : list[Node]
        List of already resolved nodes
    unresolved : list[Node]
        List of unresolved nodes

    Raises
    ------
    CircularReferenceException
        If the config contains at least one node with a circular dependency.
    """

    unresolved.append(node)
    for edge in node.depends_on:
        if edge not in resolved:
            if edge in unresolved:
                raise CircularReferenceException(node.comp_id, edge.comp_id)
            dep_resolve(edge, resolved, unresolved)
    resolved.append(node)
    unresolved.remove(node)


def resolve_concurrent_start(next_list):
    """Computes which components in the component list can be started simultaneously and returns a respective start-hierarchy with concurrent starts.

    Parameters
    ----------
    next_list : list[Node]
        List of nodes that will be started. This list ideally should be generated by `depTree.dep_resolve`.

    Returns
    -------
    list[list[Node]]
        A list, where each item is a list containing nodes that can be started at the same time.
        The component batches are sorted from early to later start, i.e., batch 1 can be started after batch 0.
    """
    hierarchy = []
    started = []
    while len(next_list) > 0:
        starting = []
        should_start = []
        node_list = next_list.copy()
        next_list.clear()
        for node in node_list:
            move_on = False
            if len(node.depends_on) > 0:  # need to check if deps are started
                for dep in node.depends_on:
                    if dep.comp_id not in started:
                        next_list.append(node)
                        move_on = True
                        break
                if move_on:
                    continue
            should_start.append(node)
            starting.append(node.comp_id)
        started.extend(starting)
        hierarchy.append(should_start)
    return hierarchy
